{"version":3,"sources":["../../src/utils/errors.ts","../../src/utils/network.ts","../../src/core/instance.ts","../../src/utils/validation.ts","../../src/core/encryption.ts","../../src/core/decryption.ts","../../src/core/permissions.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\r\n * Custom error classes for FHEVM SDK\r\n */\r\n\r\nexport class FhevmError extends Error {\r\n  constructor(message: string) {\r\n    super(message)\r\n    this.name = 'FhevmError'\r\n    Object.setPrototypeOf(this, FhevmError.prototype)\r\n  }\r\n}\r\n\r\nexport class FhevmNotReadyError extends FhevmError {\r\n  constructor() {\r\n    super('FHEVM instance is not ready. Wait for initialization to complete.')\r\n    this.name = 'FhevmNotReadyError'\r\n    Object.setPrototypeOf(this, FhevmNotReadyError.prototype)\r\n  }\r\n}\r\n\r\nexport class EncryptionError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Encryption failed: ${message}`)\r\n    this.name = 'EncryptionError'\r\n    Object.setPrototypeOf(this, EncryptionError.prototype)\r\n  }\r\n}\r\n\r\nexport class DecryptionError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Decryption failed: ${message}`)\r\n    this.name = 'DecryptionError'\r\n    Object.setPrototypeOf(this, DecryptionError.prototype)\r\n  }\r\n}\r\n\r\nexport class NetworkError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Network error: ${message}`)\r\n    this.name = 'NetworkError'\r\n    Object.setPrototypeOf(this, NetworkError.prototype)\r\n  }\r\n}\r\n\r\nexport class ValidationError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Validation error: ${message}`)\r\n    this.name = 'ValidationError'\r\n    Object.setPrototypeOf(this, ValidationError.prototype)\r\n  }\r\n}\r\n\r\nexport class PermissionError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Permission error: ${message}`)\r\n    this.name = 'PermissionError'\r\n    Object.setPrototypeOf(this, PermissionError.prototype)\r\n  }\r\n}\r\n","/**\r\n * Network configuration utilities for FHEVM SDK\r\n */\r\n\r\nimport type { NetworkName, NetworkConfig } from '../types'\r\nimport { NetworkError } from './errors'\r\n\r\n/**\r\n * Predefined network configurations\r\n */\r\nexport const NETWORK_CONFIGS: Record<NetworkName, NetworkConfig> = {\r\n  sepolia: {\r\n    name: 'sepolia',\r\n    chainId: 11155111,\r\n    rpcUrl: 'https://sepolia.infura.io/v3/',\r\n    gatewayUrl: 'https://gateway.sepolia.zama.ai',\r\n    aclAddress: '0x9d6f6d3D3D3D3D3D3D3D3D3D3D3D3D3D3D3D3D3D',\r\n  },\r\n  mainnet: {\r\n    name: 'mainnet',\r\n    chainId: 1,\r\n    rpcUrl: 'https://mainnet.infura.io/v3/',\r\n    gatewayUrl: 'https://gateway.zama.ai',\r\n    aclAddress: '0x0000000000000000000000000000000000000000',\r\n  },\r\n  localhost: {\r\n    name: 'localhost',\r\n    chainId: 31337,\r\n    rpcUrl: 'http://localhost:8545',\r\n    gatewayUrl: 'http://localhost:3000',\r\n  },\r\n  custom: {\r\n    name: 'custom',\r\n    chainId: 0,\r\n    rpcUrl: '',\r\n    gatewayUrl: '',\r\n  },\r\n}\r\n\r\n/**\r\n * Get network configuration by name\r\n */\r\nexport function getNetworkConfig(network: NetworkName): NetworkConfig {\r\n  const config = NETWORK_CONFIGS[network]\r\n  if (!config) {\r\n    throw new NetworkError(`Unknown network: ${network}`)\r\n  }\r\n  return { ...config }\r\n}\r\n\r\n/**\r\n * Validate network configuration\r\n */\r\nexport function validateNetworkConfig(config: NetworkConfig): void {\r\n  if (!config.chainId || config.chainId <= 0) {\r\n    throw new NetworkError('Invalid chainId')\r\n  }\r\n\r\n  if (!config.rpcUrl || !isValidUrl(config.rpcUrl)) {\r\n    throw new NetworkError('Invalid RPC URL')\r\n  }\r\n\r\n  if (!config.gatewayUrl || !isValidUrl(config.gatewayUrl)) {\r\n    throw new NetworkError('Invalid gateway URL')\r\n  }\r\n}\r\n\r\n/**\r\n * Merge custom config with default network config\r\n */\r\nexport function mergeNetworkConfig(\r\n  network: NetworkName,\r\n  customConfig: Partial<NetworkConfig>\r\n): NetworkConfig {\r\n  const baseConfig = getNetworkConfig(network)\r\n  const merged = { ...baseConfig, ...customConfig }\r\n  validateNetworkConfig(merged)\r\n  return merged\r\n}\r\n\r\n/**\r\n * Validate URL format\r\n */\r\nfunction isValidUrl(url: string): boolean {\r\n  try {\r\n    new URL(url)\r\n    return true\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Get chain ID from network name\r\n */\r\nexport function getChainId(network: NetworkName): number {\r\n  return getNetworkConfig(network).chainId\r\n}\r\n\r\n/**\r\n * Get gateway URL from network name\r\n */\r\nexport function getGatewayUrl(network: NetworkName): string {\r\n  return getNetworkConfig(network).gatewayUrl\r\n}\r\n\r\n/**\r\n * Check if network is supported\r\n */\r\nexport function isSupportedNetwork(network: string): network is NetworkName {\r\n  return network in NETWORK_CONFIGS\r\n}\r\n","/**\r\n * FHEVM instance creation and management\r\n */\r\n\r\nimport { createInstance } from 'fhevmjs'\r\nimport { BrowserProvider, JsonRpcProvider, type Signer, type Provider } from 'ethers'\r\nimport type {\r\n  FhevmConfig,\r\n  FhevmInstance,\r\n  FhevmjsInstance,\r\n  NetworkConfig,\r\n  NetworkName,\r\n} from '../types'\r\nimport { getNetworkConfig, validateNetworkConfig } from '../utils/network'\r\nimport { NetworkError, FhevmError } from '../utils/errors'\r\n\r\n/**\r\n * Create a new FHEVM instance\r\n *\r\n * @param config - Configuration for the FHEVM instance\r\n * @returns Promise resolving to an FhevmInstance\r\n *\r\n * @example\r\n * ```typescript\r\n * // Simple usage with network name\r\n * const instance = await createFhevmInstance({ network: 'sepolia' })\r\n *\r\n * // With custom provider\r\n * const provider = new BrowserProvider(window.ethereum)\r\n * const instance = await createFhevmInstance({\r\n *   network: 'sepolia',\r\n *   provider\r\n * })\r\n *\r\n * // With full custom config\r\n * const instance = await createFhevmInstance({\r\n *   network: {\r\n *     name: 'custom',\r\n *     chainId: 31337,\r\n *     rpcUrl: 'http://localhost:8545',\r\n *     gatewayUrl: 'http://localhost:3000'\r\n *   }\r\n * })\r\n * ```\r\n */\r\nexport async function createFhevmInstance(config: FhevmConfig): Promise<FhevmInstance> {\r\n  try {\r\n    // Parse network configuration\r\n    const networkConfig = parseNetworkConfig(config)\r\n\r\n    // Provider available for future use if needed\r\n    // const provider = config.provider || (await getDefaultProvider(networkConfig))\r\n\r\n    // Create fhevmjs instance\r\n    const fhevmjsInstance = await createInstance({\r\n      networkUrl: networkConfig.rpcUrl,\r\n      gatewayUrl: networkConfig.gatewayUrl,\r\n      aclAddress: networkConfig.aclAddress,\r\n      chainId: networkConfig.chainId,\r\n    })\r\n\r\n    // Get public key\r\n    const publicKey = fhevmjsInstance.getPublicKey()\r\n\r\n    return {\r\n      instance: fhevmjsInstance as any as FhevmjsInstance,\r\n      config: networkConfig,\r\n      ready: true,\r\n      publicKey: publicKey || undefined,\r\n    } as FhevmInstance\r\n  } catch (error) {\r\n    throw new FhevmError(`Failed to create FHEVM instance: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Parse network configuration from user input\r\n */\r\nfunction parseNetworkConfig(config: FhevmConfig): NetworkConfig {\r\n  if (typeof config.network === 'string') {\r\n    // Network name provided\r\n    const baseConfig = getNetworkConfig(config.network as NetworkName)\r\n\r\n    // Merge with custom values\r\n    const merged: NetworkConfig = {\r\n      ...baseConfig,\r\n      ...(config.gatewayUrl && { gatewayUrl: config.gatewayUrl }),\r\n      ...(config.chainId && { chainId: config.chainId }),\r\n    }\r\n\r\n    validateNetworkConfig(merged)\r\n    return merged\r\n  }\r\n\r\n  // Full network config provided\r\n  const networkConfig = config.network as NetworkConfig\r\n  validateNetworkConfig(networkConfig)\r\n  return networkConfig\r\n}\r\n\r\n/**\r\n * Get default provider for the network\r\n */\r\nasync function getDefaultProvider(config: NetworkConfig): Promise<Provider> {\r\n  // Try to use browser provider first (MetaMask, etc.)\r\n  if (typeof window !== 'undefined' && (window as any).ethereum) {\r\n    try {\r\n      const browserProvider = new BrowserProvider((window as any).ethereum)\r\n      const network = await browserProvider.getNetwork()\r\n\r\n      // Verify chain ID matches\r\n      if (Number(network.chainId) !== config.chainId) {\r\n        throw new NetworkError(\r\n          `Connected wallet is on chain ${network.chainId}, expected ${config.chainId}`\r\n        )\r\n      }\r\n\r\n      return browserProvider\r\n    } catch (error) {\r\n      console.warn('Browser provider not available or wrong network:', error)\r\n    }\r\n  }\r\n\r\n  // Fallback to JSON-RPC provider\r\n  return new JsonRpcProvider(config.rpcUrl, config.chainId)\r\n}\r\n\r\n/**\r\n * Get signer from provider\r\n */\r\nexport async function getSigner(instance: FhevmInstance, provider?: Provider): Promise<Signer> {\r\n  const targetProvider = provider || (await getDefaultProvider(instance.config))\r\n\r\n  if ('getSigner' in targetProvider && typeof targetProvider.getSigner === 'function') {\r\n    return await (targetProvider as any).getSigner()\r\n  }\r\n\r\n  throw new FhevmError('Provider does not support getting signer')\r\n}\r\n\r\n\r\n/**\r\n * Check if FHEVM instance is ready\r\n */\r\nexport function isInstanceReady(instance: FhevmInstance | null): instance is FhevmInstance {\r\n  return instance !== null && instance.ready\r\n}\r\n\r\n/**\r\n * Get public key from instance\r\n */\r\nexport function getPublicKey(instance: FhevmInstance): string {\r\n  if (!instance.publicKey) {\r\n    const key = instance.instance.getPublicKey()\r\n    instance.publicKey = key || undefined\r\n  }\r\n\r\n  if (!instance.publicKey) {\r\n    throw new FhevmError('Public key not available')\r\n  }\r\n\r\n  return instance.publicKey\r\n}\r\n\r\n/**\r\n * Reinitialize FHEVM instance with new configuration\r\n */\r\nexport async function reinitializeInstance(\r\n  currentInstance: FhevmInstance,\r\n  newConfig: Partial<FhevmConfig>\r\n): Promise<FhevmInstance> {\r\n  const mergedConfig: FhevmConfig = {\r\n    network: currentInstance.config,\r\n    ...newConfig,\r\n  }\r\n\r\n  return await createFhevmInstance(mergedConfig)\r\n}\r\n","/**\r\n * Input validation utilities for FHEVM SDK\r\n */\r\n\r\nimport type { InputType, EncryptedType } from '../types'\r\nimport { ValidationError } from './errors'\r\n\r\n/**\r\n * Mapping from input types to encrypted types\r\n */\r\nexport const INPUT_TO_ENCRYPTED_TYPE: Record<InputType, EncryptedType> = {\r\n  bool: 'ebool',\r\n  uint8: 'euint8',\r\n  uint16: 'euint16',\r\n  uint32: 'euint32',\r\n  uint64: 'euint64',\r\n  uint128: 'euint128',\r\n  uint256: 'euint256',\r\n  address: 'eaddress',\r\n  bytes: 'ebytes256',\r\n}\r\n\r\n/**\r\n * Maximum values for unsigned integer types\r\n */\r\nconst MAX_VALUES: Record<string, bigint> = {\r\n  uint8: BigInt(2 ** 8 - 1),\r\n  uint16: BigInt(2 ** 16 - 1),\r\n  uint32: BigInt(2 ** 32 - 1),\r\n  uint64: BigInt(2 ** 64 - 1),\r\n  uint128: BigInt(2 ** 128 - 1),\r\n  uint256: (BigInt(2) ** BigInt(256)) - BigInt(1),\r\n}\r\n\r\n/**\r\n * Validate input value for encryption\r\n */\r\nexport function validateEncryptionInput(\r\n  value: number | boolean | bigint | string,\r\n  type: InputType\r\n): void {\r\n  if (type === 'bool') {\r\n    if (typeof value !== 'boolean') {\r\n      throw new ValidationError(`Expected boolean for type 'bool', got ${typeof value}`)\r\n    }\r\n    return\r\n  }\r\n\r\n  if (type === 'address') {\r\n    if (typeof value !== 'string') {\r\n      throw new ValidationError(`Expected string for type 'address', got ${typeof value}`)\r\n    }\r\n    if (!isValidAddress(value)) {\r\n      throw new ValidationError(`Invalid Ethereum address: ${value}`)\r\n    }\r\n    return\r\n  }\r\n\r\n  if (type === 'bytes') {\r\n    if (typeof value !== 'string') {\r\n      throw new ValidationError(`Expected string for type 'bytes', got ${typeof value}`)\r\n    }\r\n    if (!isValidHex(value)) {\r\n      throw new ValidationError(`Invalid hex string for bytes: ${value}`)\r\n    }\r\n    return\r\n  }\r\n\r\n  // Numeric types - ensure we have a valid numeric value\r\n  if (typeof value === 'boolean') {\r\n    throw new ValidationError(`Expected numeric value for type '${type}', got boolean`)\r\n  }\r\n\r\n  const numericValue = toBigInt(value)\r\n  const maxValue = MAX_VALUES[type]\r\n\r\n  if (!maxValue) {\r\n    throw new ValidationError(`Unknown numeric type: ${type}`)\r\n  }\r\n\r\n  if (numericValue < BigInt(0)) {\r\n    throw new ValidationError(`Value must be non-negative for type '${type}'`)\r\n  }\r\n\r\n  if (numericValue > maxValue) {\r\n    throw new ValidationError(\r\n      `Value ${numericValue} exceeds maximum for type '${type}' (max: ${maxValue})`\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Convert value to BigInt safely\r\n */\r\nexport function toBigInt(value: number | bigint | string): bigint {\r\n  try {\r\n    if (typeof value === 'bigint') {\r\n      return value\r\n    }\r\n    if (typeof value === 'number') {\r\n      if (!Number.isInteger(value)) {\r\n        throw new ValidationError('Decimal numbers not supported')\r\n      }\r\n      return BigInt(value)\r\n    }\r\n    if (typeof value === 'string') {\r\n      return BigInt(value)\r\n    }\r\n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`)\r\n  } catch (error) {\r\n    if (error instanceof ValidationError) {\r\n      throw error\r\n    }\r\n    throw new ValidationError(`Failed to convert value to BigInt: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Validate Ethereum address format\r\n */\r\nexport function isValidAddress(address: string): boolean {\r\n  return /^0x[0-9a-fA-F]{40}$/.test(address)\r\n}\r\n\r\n/**\r\n * Validate hex string format\r\n */\r\nexport function isValidHex(hex: string): boolean {\r\n  return /^0x[0-9a-fA-F]*$/.test(hex)\r\n}\r\n\r\n/**\r\n * Get encrypted type for input type\r\n */\r\nexport function getEncryptedType(inputType: InputType): EncryptedType {\r\n  const encryptedType = INPUT_TO_ENCRYPTED_TYPE[inputType]\r\n  if (!encryptedType) {\r\n    throw new ValidationError(`Unknown input type: ${inputType}`)\r\n  }\r\n  return encryptedType\r\n}\r\n\r\n/**\r\n * Validate contract address\r\n */\r\nexport function validateContractAddress(address: string): void {\r\n  if (!isValidAddress(address)) {\r\n    throw new ValidationError(`Invalid contract address: ${address}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Validate handle (ciphertext identifier)\r\n */\r\nexport function validateHandle(handle: string): void {\r\n  if (!handle || typeof handle !== 'string') {\r\n    throw new ValidationError('Handle must be a non-empty string')\r\n  }\r\n  // Handle is typically a hex string or similar identifier\r\n  if (!isValidHex(handle) && !/^[0-9a-fA-F]+$/.test(handle)) {\r\n    throw new ValidationError(`Invalid handle format: ${handle}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize value for encryption\r\n */\r\nexport function normalizeValue(\r\n  value: number | boolean | bigint | string,\r\n  type: InputType\r\n): number | boolean | bigint | string {\r\n  if (type === 'bool') {\r\n    return Boolean(value)\r\n  }\r\n\r\n  if (type === 'address') {\r\n    const addr = String(value).toLowerCase()\r\n    if (!addr.startsWith('0x')) {\r\n      return '0x' + addr\r\n    }\r\n    return addr\r\n  }\r\n\r\n  if (type === 'bytes') {\r\n    const hex = String(value).toLowerCase()\r\n    if (!hex.startsWith('0x')) {\r\n      return '0x' + hex\r\n    }\r\n    return hex\r\n  }\r\n\r\n  // Numeric types - return as-is after validation\r\n  return value\r\n}\r\n","/**\r\n * Encryption utilities for FHEVM\r\n */\r\n\r\nimport type { FhevmInstance, InputType, EncryptedValue } from '../types'\r\nimport { validateEncryptionInput, normalizeValue, getEncryptedType } from '../utils/validation'\r\nimport { EncryptionError, FhevmNotReadyError } from '../utils/errors'\r\n\r\n/**\r\n * Encrypt a value using the FHEVM instance\r\n *\r\n * @param instance - FHEVM instance to use for encryption\r\n * @param value - Value to encrypt\r\n * @param type - Type of the value\r\n * @returns Promise resolving to encrypted value\r\n *\r\n * @example\r\n * ```typescript\r\n * const instance = await createFhevmInstance({ network: 'sepolia' })\r\n *\r\n * // Encrypt a number\r\n * const encrypted = await encryptValue(instance, 42, 'uint32')\r\n *\r\n * // Encrypt a boolean\r\n * const encryptedBool = await encryptValue(instance, true, 'bool')\r\n *\r\n * // Encrypt an address\r\n * const encryptedAddr = await encryptValue(\r\n *   instance,\r\n *   '0x1234567890123456789012345678901234567890',\r\n *   'address'\r\n * )\r\n * ```\r\n */\r\nexport async function encryptValue<T extends InputType>(\r\n  instance: FhevmInstance,\r\n  value: number | boolean | bigint | string,\r\n  type: T\r\n): Promise<EncryptedValue<T>> {\r\n  // Validate instance is ready\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  // Validate input\r\n  validateEncryptionInput(value, type)\r\n\r\n  // Normalize value\r\n  const normalized = normalizeValue(value, type)\r\n\r\n  try {\r\n    // Encrypt using fhevmjs\r\n    const encrypted = await encryptWithFhevmjs(instance, normalized, type)\r\n\r\n    return {\r\n      data: encrypted,\r\n      type,\r\n      encryptedType: getEncryptedType(type),\r\n    }\r\n  } catch (error) {\r\n    throw new EncryptionError(`Failed to encrypt ${type}: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Encrypt value using fhevmjs instance\r\n */\r\nasync function encryptWithFhevmjs(\r\n  instance: FhevmInstance,\r\n  value: number | boolean | bigint | string,\r\n  type: InputType\r\n): Promise<Uint8Array> {\r\n  const fhevmInstance = instance.instance\r\n\r\n  switch (type) {\r\n    case 'bool':\r\n      return fhevmInstance.encrypt_bool(value as boolean)\r\n\r\n    case 'uint8':\r\n      return fhevmInstance.encrypt_uint8(Number(value))\r\n\r\n    case 'uint16':\r\n      return fhevmInstance.encrypt_uint16(Number(value))\r\n\r\n    case 'uint32':\r\n      return fhevmInstance.encrypt_uint32(Number(value))\r\n\r\n    case 'uint64':\r\n      return fhevmInstance.encrypt_uint64(BigInt(value))\r\n\r\n    case 'uint128':\r\n      return fhevmInstance.encrypt_uint128(BigInt(value))\r\n\r\n    case 'uint256':\r\n      return fhevmInstance.encrypt_uint256(BigInt(value))\r\n\r\n    case 'address':\r\n      return fhevmInstance.encrypt_address(value as string)\r\n\r\n    case 'bytes':\r\n      return fhevmInstance.encrypt_bytes256(value as string)\r\n\r\n    default:\r\n      throw new EncryptionError(`Unsupported encryption type: ${type}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Encrypt multiple values at once\r\n *\r\n * @param instance - FHEVM instance\r\n * @param values - Array of values with their types\r\n * @returns Promise resolving to array of encrypted values\r\n *\r\n * @example\r\n * ```typescript\r\n * const encrypted = await encryptBatch(instance, [\r\n *   { value: 42, type: 'uint32' },\r\n *   { value: true, type: 'bool' },\r\n *   { value: 100n, type: 'uint64' }\r\n * ])\r\n * ```\r\n */\r\nexport async function encryptBatch(\r\n  instance: FhevmInstance,\r\n  values: Array<{ value: number | boolean | bigint | string; type: InputType }>\r\n): Promise<EncryptedValue[]> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  try {\r\n    const encrypted = await Promise.all(\r\n      values.map(({ value, type }) => encryptValue(instance, value, type))\r\n    )\r\n    return encrypted\r\n  } catch (error) {\r\n    throw new EncryptionError(`Batch encryption failed: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Convert encrypted value to contract input format\r\n *\r\n * @param encrypted - Encrypted value\r\n * @returns Formatted data for contract call\r\n *\r\n * @example\r\n * ```typescript\r\n * const encrypted = await encryptValue(instance, 42, 'uint32')\r\n * const input = toContractInput(encrypted)\r\n * await contract.submitValue(input)\r\n * ```\r\n */\r\nexport function toContractInput(encrypted: EncryptedValue): Uint8Array {\r\n  return encrypted.data\r\n}\r\n\r\n/**\r\n * Convert encrypted value to hex string\r\n *\r\n * @param encrypted - Encrypted value\r\n * @returns Hex string representation\r\n */\r\nexport function toHex(encrypted: EncryptedValue): string {\r\n  return '0x' + Array.from(encrypted.data).map((b) => b.toString(16).padStart(2, '0')).join('')\r\n}\r\n\r\n/**\r\n * Get size of encrypted value in bytes\r\n *\r\n * @param encrypted - Encrypted value\r\n * @returns Size in bytes\r\n */\r\nexport function getEncryptedSize(encrypted: EncryptedValue): number {\r\n  return encrypted.data.length\r\n}\r\n\r\n/**\r\n * Check if two encrypted values are equal (same ciphertext)\r\n *\r\n * @param a - First encrypted value\r\n * @param b - Second encrypted value\r\n * @returns True if equal\r\n */\r\nexport function areEncryptedValuesEqual(a: EncryptedValue, b: EncryptedValue): boolean {\r\n  if (a.data.length !== b.data.length) {\r\n    return false\r\n  }\r\n\r\n  for (let i = 0; i < a.data.length; i++) {\r\n    if (a.data[i] !== b.data[i]) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n","/**\r\n * Decryption utilities for FHEVM via Gateway\r\n */\r\n\r\nimport type { FhevmInstance, EncryptedType } from '../types'\r\nimport { validateContractAddress, validateHandle } from '../utils/validation'\r\nimport { DecryptionError, FhevmNotReadyError } from '../utils/errors'\r\n// import { getSigner } from './instance' // For future use\r\n\r\n/**\r\n * Request decryption of an encrypted value via the Gateway\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Address of the contract holding the encrypted value\r\n * @param handle - Handle/identifier of the encrypted value (ciphertext)\r\n * @param type - Expected type of the decrypted value\r\n * @returns Promise resolving to decrypted value\r\n *\r\n * @example\r\n * ```typescript\r\n * // After submitting encrypted data to contract and getting a handle\r\n * const decrypted = await requestDecryption(\r\n *   instance,\r\n *   '0x1234...', // contract address\r\n *   '0xabcd...', // ciphertext handle\r\n *   'uint32'\r\n * )\r\n * console.log('Decrypted value:', decrypted)\r\n * ```\r\n */\r\nexport async function requestDecryption<T = unknown>(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  type?: EncryptedType\r\n): Promise<T> {\r\n  // Validate instance\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  // Validate inputs\r\n  validateContractAddress(contractAddress)\r\n  validateHandle(handle)\r\n\r\n  try {\r\n    // Get signer for signing the decryption request (for future use)\r\n    // const signer = await getSigner(instance)\r\n    // const userAddress = await signer.getAddress()\r\n\r\n    // Create decryption request using fhevmjs - currently uses instance's internal methods\r\n    if (!instance.instance.decrypt) {\r\n      throw new DecryptionError('Decryption not supported by this instance')\r\n    }\r\n    const result = await instance.instance.decrypt(contractAddress, handle)\r\n\r\n    // Parse result based on type\r\n    return parseDecryptionResult<T>(result, type)\r\n  } catch (error) {\r\n    throw new DecryptionError(`Failed to decrypt value: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Request decryption with explicit permission signature\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @param signature - Permission signature from user\r\n * @param type - Expected type\r\n * @returns Decrypted value\r\n */\r\nexport async function requestDecryptionWithSignature<T = unknown>(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  signature: string,\r\n  type?: EncryptedType\r\n): Promise<T> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n  validateHandle(handle)\r\n\r\n  try {\r\n    // Use provided signature instead of generating new one\r\n    if (!instance.instance.decrypt) {\r\n      throw new DecryptionError('Decryption not supported by this instance')\r\n    }\r\n    const result = await instance.instance.decrypt(contractAddress, handle, signature)\r\n    return parseDecryptionResult<T>(result, type)\r\n  } catch (error) {\r\n    throw new DecryptionError(`Failed to decrypt with signature: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Request batch decryption\r\n *\r\n * @param instance - FHEVM instance\r\n * @param requests - Array of decryption requests\r\n * @returns Array of decrypted values\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = await requestBatchDecryption(instance, [\r\n *   { contractAddress: '0x123...', handle: '0xabc...', type: 'uint32' },\r\n *   { contractAddress: '0x123...', handle: '0xdef...', type: 'bool' }\r\n * ])\r\n * ```\r\n */\r\nexport async function requestBatchDecryption(\r\n  instance: FhevmInstance,\r\n  requests: Array<{\r\n    contractAddress: string\r\n    handle: string\r\n    type?: EncryptedType\r\n  }>\r\n): Promise<unknown[]> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  try {\r\n    const results = await Promise.all(\r\n      requests.map(({ contractAddress, handle, type }) =>\r\n        requestDecryption(instance, contractAddress, handle, type)\r\n      )\r\n    )\r\n    return results\r\n  } catch (error) {\r\n    throw new DecryptionError(`Batch decryption failed: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Parse decryption result based on expected type\r\n */\r\nfunction parseDecryptionResult<T>(result: any, type?: EncryptedType): T {\r\n  if (type === undefined) {\r\n    return result as T\r\n  }\r\n\r\n  switch (type) {\r\n    case 'ebool':\r\n      return Boolean(result) as T\r\n\r\n    case 'euint4':\r\n    case 'euint8':\r\n    case 'euint16':\r\n    case 'euint32':\r\n      return Number(result) as T\r\n\r\n    case 'euint64':\r\n    case 'euint128':\r\n    case 'euint256':\r\n      return BigInt(result) as T\r\n\r\n    case 'eaddress':\r\n      return String(result) as T\r\n\r\n    case 'ebytes64':\r\n    case 'ebytes128':\r\n    case 'ebytes256':\r\n      return String(result) as T\r\n\r\n    default:\r\n      return result as T\r\n  }\r\n}\r\n\r\n/**\r\n * Wait for decryption to be fulfilled\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @param options - Polling options\r\n * @returns Decrypted value when ready\r\n *\r\n * @example\r\n * ```typescript\r\n * // Wait up to 30 seconds, polling every 2 seconds\r\n * const value = await waitForDecryption(\r\n *   instance,\r\n *   contractAddress,\r\n *   handle,\r\n *   { timeout: 30000, interval: 2000 }\r\n * )\r\n * ```\r\n */\r\nexport async function waitForDecryption<T = unknown>(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  options: {\r\n    timeout?: number\r\n    interval?: number\r\n    type?: EncryptedType\r\n  } = {}\r\n): Promise<T> {\r\n  const { timeout = 60000, interval = 1000, type } = options\r\n\r\n  const startTime = Date.now()\r\n\r\n  while (Date.now() - startTime < timeout) {\r\n    try {\r\n      const result = await requestDecryption<T>(instance, contractAddress, handle, type)\r\n      return result\r\n    } catch (error) {\r\n      // If it's a \"not ready\" error, wait and retry\r\n      if (error instanceof DecryptionError && error.message.includes('not ready')) {\r\n        await new Promise((resolve) => setTimeout(resolve, interval))\r\n        continue\r\n      }\r\n      // Other errors should be thrown immediately\r\n      throw error\r\n    }\r\n  }\r\n\r\n  throw new DecryptionError(`Decryption timeout after ${timeout}ms`)\r\n}\r\n\r\n/**\r\n * Check if decryption is available for a handle\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @returns True if decryption is available\r\n */\r\nexport async function isDecryptionReady(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string\r\n): Promise<boolean> {\r\n  try {\r\n    await requestDecryption(instance, contractAddress, handle)\r\n    return true\r\n  } catch (error) {\r\n    return false\r\n  }\r\n}\r\n","/**\r\n * Permission management utilities for FHEVM\r\n */\r\n\r\nimport type { FhevmInstance, PermissionConfig } from '../types'\r\nimport { validateContractAddress, isValidAddress } from '../utils/validation'\r\nimport { PermissionError, FhevmNotReadyError } from '../utils/errors'\r\nimport { getSigner } from './instance'\r\n\r\n/**\r\n * Generate permission signature for decryption\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Address of the contract\r\n * @param userAddress - Address of the user requesting permission (optional, defaults to signer)\r\n * @returns Permission signature\r\n *\r\n * @example\r\n * ```typescript\r\n * const signature = await generatePermission(instance, contractAddress)\r\n * // Use signature for decryption requests\r\n * ```\r\n */\r\nexport async function generatePermission(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  userAddress?: string\r\n): Promise<string> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n\r\n  try {\r\n    const signer = await getSigner(instance)\r\n    const address = userAddress || (await signer.getAddress())\r\n\r\n    if (!isValidAddress(address)) {\r\n      throw new PermissionError(`Invalid user address: ${address}`)\r\n    }\r\n\r\n    // Generate EIP-712 signature for permission\r\n    if (!instance.instance.generatePermitSignature) {\r\n      throw new PermissionError('Permission signature generation not supported by this instance')\r\n    }\r\n    const signature = await instance.instance.generatePermitSignature(contractAddress, address)\r\n\r\n    return signature\r\n  } catch (error) {\r\n    throw new PermissionError(`Failed to generate permission: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Request permission from contract (ACL-based)\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @returns Transaction receipt\r\n *\r\n * @example\r\n * ```typescript\r\n * // Request permission to decrypt a specific ciphertext\r\n * await requestPermission(instance, contractAddress, handle)\r\n * ```\r\n */\r\nexport async function requestPermission(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string\r\n): Promise<void> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n\r\n  try {\r\n    // This would typically interact with the ACL contract\r\n    // Implementation depends on the specific ACL contract interface\r\n    throw new PermissionError('ACL-based permissions not yet implemented')\r\n  } catch (error) {\r\n    throw new PermissionError(`Failed to request permission: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user has permission to decrypt a value\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @param userAddress - User address (optional, defaults to signer)\r\n * @returns True if user has permission\r\n *\r\n * @example\r\n * ```typescript\r\n * const hasPermission = await checkPermission(instance, contractAddress, handle)\r\n * if (hasPermission) {\r\n *   const decrypted = await requestDecryption(instance, contractAddress, handle)\r\n * }\r\n * ```\r\n */\r\nexport async function checkPermission(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  userAddress?: string\r\n): Promise<boolean> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n\r\n  try {\r\n    const signer = await getSigner(instance)\r\n    const address = userAddress || (await signer.getAddress())\r\n\r\n    // This would check the ACL contract\r\n    // For now, return true (implement based on actual ACL contract)\r\n    return true\r\n  } catch (error) {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Grant permission to another address\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param targetAddress - Address to grant permission to\r\n * @param handle - Ciphertext handle\r\n * @returns Transaction receipt\r\n *\r\n * @example\r\n * ```typescript\r\n * // Grant permission to another user\r\n * await grantPermission(\r\n *   instance,\r\n *   contractAddress,\r\n *   '0x1234...', // target user\r\n *   handle\r\n * )\r\n * ```\r\n */\r\nexport async function grantPermission(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  targetAddress: string,\r\n  handle: string\r\n): Promise<void> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n\r\n  if (!isValidAddress(targetAddress)) {\r\n    throw new PermissionError(`Invalid target address: ${targetAddress}`)\r\n  }\r\n\r\n  try {\r\n    // This would interact with the ACL contract to grant permission\r\n    throw new PermissionError('Permission granting not yet implemented')\r\n  } catch (error) {\r\n    throw new PermissionError(`Failed to grant permission: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Revoke permission from an address\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param targetAddress - Address to revoke permission from\r\n * @param handle - Ciphertext handle\r\n * @returns Transaction receipt\r\n */\r\nexport async function revokePermission(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  targetAddress: string,\r\n  handle: string\r\n): Promise<void> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n\r\n  if (!isValidAddress(targetAddress)) {\r\n    throw new PermissionError(`Invalid target address: ${targetAddress}`)\r\n  }\r\n\r\n  try {\r\n    // This would interact with the ACL contract to revoke permission\r\n    throw new PermissionError('Permission revocation not yet implemented')\r\n  } catch (error) {\r\n    throw new PermissionError(`Failed to revoke permission: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Get all addresses with permission for a handle\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @returns Array of addresses with permission\r\n */\r\nexport async function getPermittedAddresses(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string\r\n): Promise<string[]> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n\r\n  try {\r\n    // This would query the ACL contract\r\n    return []\r\n  } catch (error) {\r\n    throw new PermissionError(`Failed to get permitted addresses: ${error}`)\r\n  }\r\n}\r\n"]}