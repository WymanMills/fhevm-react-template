{"version":3,"sources":["../../src/react/context/FhevmContext.tsx","../../src/utils/errors.ts","../../src/react/hooks/useFhevm.ts","../../src/utils/validation.ts","../../src/core/encryption.ts","../../src/react/hooks/useEncrypt.ts","../../src/core/decryption.ts","../../src/react/hooks/useDecrypt.ts","../../src/utils/network.ts","../../src/core/instance.ts","../../src/providers/FhevmProvider.tsx"],"names":["createContext","useContext","useState","useCallback","error","createInstance","useEffect","useMemo"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * React Context for FHEVM instance\r\n */\r\n\r\nimport { createContext } from 'react'\r\nimport type { FhevmInstance } from '../../types'\r\n\r\nexport interface FhevmContextValue {\r\n  instance: FhevmInstance | null\r\n  ready: boolean\r\n  error: Error | null\r\n  loading: boolean\r\n}\r\n\r\nexport const FhevmContext = createContext<FhevmContextValue | null>(null)\r\n\r\nFhevmContext.displayName = 'FhevmContext'\r\n","/**\r\n * Custom error classes for FHEVM SDK\r\n */\r\n\r\nexport class FhevmError extends Error {\r\n  constructor(message: string) {\r\n    super(message)\r\n    this.name = 'FhevmError'\r\n    Object.setPrototypeOf(this, FhevmError.prototype)\r\n  }\r\n}\r\n\r\nexport class FhevmNotReadyError extends FhevmError {\r\n  constructor() {\r\n    super('FHEVM instance is not ready. Wait for initialization to complete.')\r\n    this.name = 'FhevmNotReadyError'\r\n    Object.setPrototypeOf(this, FhevmNotReadyError.prototype)\r\n  }\r\n}\r\n\r\nexport class EncryptionError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Encryption failed: ${message}`)\r\n    this.name = 'EncryptionError'\r\n    Object.setPrototypeOf(this, EncryptionError.prototype)\r\n  }\r\n}\r\n\r\nexport class DecryptionError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Decryption failed: ${message}`)\r\n    this.name = 'DecryptionError'\r\n    Object.setPrototypeOf(this, DecryptionError.prototype)\r\n  }\r\n}\r\n\r\nexport class NetworkError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Network error: ${message}`)\r\n    this.name = 'NetworkError'\r\n    Object.setPrototypeOf(this, NetworkError.prototype)\r\n  }\r\n}\r\n\r\nexport class ValidationError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Validation error: ${message}`)\r\n    this.name = 'ValidationError'\r\n    Object.setPrototypeOf(this, ValidationError.prototype)\r\n  }\r\n}\r\n\r\nexport class PermissionError extends FhevmError {\r\n  constructor(message: string) {\r\n    super(`Permission error: ${message}`)\r\n    this.name = 'PermissionError'\r\n    Object.setPrototypeOf(this, PermissionError.prototype)\r\n  }\r\n}\r\n","/**\r\n * React hook for accessing FHEVM instance\r\n */\r\n\r\nimport { useContext } from 'react'\r\nimport { FhevmContext } from '../context/FhevmContext'\r\nimport type { UseFhevmState } from '../../types'\r\nimport { FhevmError } from '../../utils/errors'\r\n\r\n/**\r\n * Hook to access FHEVM instance from context\r\n *\r\n * @returns FHEVM instance state\r\n *\r\n * @example\r\n * ```typescript\r\n * function MyComponent() {\r\n *   const { instance, ready, error, loading } = useFhevm()\r\n *\r\n *   if (loading) return <div>Loading FHEVM...</div>\r\n *   if (error) return <div>Error: {error.message}</div>\r\n *   if (!ready) return <div>Initializing...</div>\r\n *\r\n *   return <div>FHEVM ready!</div>\r\n * }\r\n * ```\r\n */\r\nexport function useFhevm(): UseFhevmState {\r\n  const context = useContext(FhevmContext)\r\n\r\n  if (!context) {\r\n    throw new FhevmError(\r\n      'useFhevm must be used within FhevmProvider. ' +\r\n        'Wrap your component tree with <FhevmProvider>.'\r\n    )\r\n  }\r\n\r\n  return {\r\n    instance: context.instance,\r\n    ready: context.ready,\r\n    error: context.error,\r\n    loading: context.loading,\r\n  }\r\n}\r\n","/**\r\n * Input validation utilities for FHEVM SDK\r\n */\r\n\r\nimport type { InputType, EncryptedType } from '../types'\r\nimport { ValidationError } from './errors'\r\n\r\n/**\r\n * Mapping from input types to encrypted types\r\n */\r\nexport const INPUT_TO_ENCRYPTED_TYPE: Record<InputType, EncryptedType> = {\r\n  bool: 'ebool',\r\n  uint8: 'euint8',\r\n  uint16: 'euint16',\r\n  uint32: 'euint32',\r\n  uint64: 'euint64',\r\n  uint128: 'euint128',\r\n  uint256: 'euint256',\r\n  address: 'eaddress',\r\n  bytes: 'ebytes256',\r\n}\r\n\r\n/**\r\n * Maximum values for unsigned integer types\r\n */\r\nconst MAX_VALUES: Record<string, bigint> = {\r\n  uint8: BigInt(2 ** 8 - 1),\r\n  uint16: BigInt(2 ** 16 - 1),\r\n  uint32: BigInt(2 ** 32 - 1),\r\n  uint64: BigInt(2 ** 64 - 1),\r\n  uint128: BigInt(2 ** 128 - 1),\r\n  uint256: (BigInt(2) ** BigInt(256)) - BigInt(1),\r\n}\r\n\r\n/**\r\n * Validate input value for encryption\r\n */\r\nexport function validateEncryptionInput(\r\n  value: number | boolean | bigint | string,\r\n  type: InputType\r\n): void {\r\n  if (type === 'bool') {\r\n    if (typeof value !== 'boolean') {\r\n      throw new ValidationError(`Expected boolean for type 'bool', got ${typeof value}`)\r\n    }\r\n    return\r\n  }\r\n\r\n  if (type === 'address') {\r\n    if (typeof value !== 'string') {\r\n      throw new ValidationError(`Expected string for type 'address', got ${typeof value}`)\r\n    }\r\n    if (!isValidAddress(value)) {\r\n      throw new ValidationError(`Invalid Ethereum address: ${value}`)\r\n    }\r\n    return\r\n  }\r\n\r\n  if (type === 'bytes') {\r\n    if (typeof value !== 'string') {\r\n      throw new ValidationError(`Expected string for type 'bytes', got ${typeof value}`)\r\n    }\r\n    if (!isValidHex(value)) {\r\n      throw new ValidationError(`Invalid hex string for bytes: ${value}`)\r\n    }\r\n    return\r\n  }\r\n\r\n  // Numeric types - ensure we have a valid numeric value\r\n  if (typeof value === 'boolean') {\r\n    throw new ValidationError(`Expected numeric value for type '${type}', got boolean`)\r\n  }\r\n\r\n  const numericValue = toBigInt(value)\r\n  const maxValue = MAX_VALUES[type]\r\n\r\n  if (!maxValue) {\r\n    throw new ValidationError(`Unknown numeric type: ${type}`)\r\n  }\r\n\r\n  if (numericValue < BigInt(0)) {\r\n    throw new ValidationError(`Value must be non-negative for type '${type}'`)\r\n  }\r\n\r\n  if (numericValue > maxValue) {\r\n    throw new ValidationError(\r\n      `Value ${numericValue} exceeds maximum for type '${type}' (max: ${maxValue})`\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Convert value to BigInt safely\r\n */\r\nexport function toBigInt(value: number | bigint | string): bigint {\r\n  try {\r\n    if (typeof value === 'bigint') {\r\n      return value\r\n    }\r\n    if (typeof value === 'number') {\r\n      if (!Number.isInteger(value)) {\r\n        throw new ValidationError('Decimal numbers not supported')\r\n      }\r\n      return BigInt(value)\r\n    }\r\n    if (typeof value === 'string') {\r\n      return BigInt(value)\r\n    }\r\n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`)\r\n  } catch (error) {\r\n    if (error instanceof ValidationError) {\r\n      throw error\r\n    }\r\n    throw new ValidationError(`Failed to convert value to BigInt: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Validate Ethereum address format\r\n */\r\nexport function isValidAddress(address: string): boolean {\r\n  return /^0x[0-9a-fA-F]{40}$/.test(address)\r\n}\r\n\r\n/**\r\n * Validate hex string format\r\n */\r\nexport function isValidHex(hex: string): boolean {\r\n  return /^0x[0-9a-fA-F]*$/.test(hex)\r\n}\r\n\r\n/**\r\n * Get encrypted type for input type\r\n */\r\nexport function getEncryptedType(inputType: InputType): EncryptedType {\r\n  const encryptedType = INPUT_TO_ENCRYPTED_TYPE[inputType]\r\n  if (!encryptedType) {\r\n    throw new ValidationError(`Unknown input type: ${inputType}`)\r\n  }\r\n  return encryptedType\r\n}\r\n\r\n/**\r\n * Validate contract address\r\n */\r\nexport function validateContractAddress(address: string): void {\r\n  if (!isValidAddress(address)) {\r\n    throw new ValidationError(`Invalid contract address: ${address}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Validate handle (ciphertext identifier)\r\n */\r\nexport function validateHandle(handle: string): void {\r\n  if (!handle || typeof handle !== 'string') {\r\n    throw new ValidationError('Handle must be a non-empty string')\r\n  }\r\n  // Handle is typically a hex string or similar identifier\r\n  if (!isValidHex(handle) && !/^[0-9a-fA-F]+$/.test(handle)) {\r\n    throw new ValidationError(`Invalid handle format: ${handle}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize value for encryption\r\n */\r\nexport function normalizeValue(\r\n  value: number | boolean | bigint | string,\r\n  type: InputType\r\n): number | boolean | bigint | string {\r\n  if (type === 'bool') {\r\n    return Boolean(value)\r\n  }\r\n\r\n  if (type === 'address') {\r\n    const addr = String(value).toLowerCase()\r\n    if (!addr.startsWith('0x')) {\r\n      return '0x' + addr\r\n    }\r\n    return addr\r\n  }\r\n\r\n  if (type === 'bytes') {\r\n    const hex = String(value).toLowerCase()\r\n    if (!hex.startsWith('0x')) {\r\n      return '0x' + hex\r\n    }\r\n    return hex\r\n  }\r\n\r\n  // Numeric types - return as-is after validation\r\n  return value\r\n}\r\n","/**\r\n * Encryption utilities for FHEVM\r\n */\r\n\r\nimport type { FhevmInstance, InputType, EncryptedValue } from '../types'\r\nimport { validateEncryptionInput, normalizeValue, getEncryptedType } from '../utils/validation'\r\nimport { EncryptionError, FhevmNotReadyError } from '../utils/errors'\r\n\r\n/**\r\n * Encrypt a value using the FHEVM instance\r\n *\r\n * @param instance - FHEVM instance to use for encryption\r\n * @param value - Value to encrypt\r\n * @param type - Type of the value\r\n * @returns Promise resolving to encrypted value\r\n *\r\n * @example\r\n * ```typescript\r\n * const instance = await createFhevmInstance({ network: 'sepolia' })\r\n *\r\n * // Encrypt a number\r\n * const encrypted = await encryptValue(instance, 42, 'uint32')\r\n *\r\n * // Encrypt a boolean\r\n * const encryptedBool = await encryptValue(instance, true, 'bool')\r\n *\r\n * // Encrypt an address\r\n * const encryptedAddr = await encryptValue(\r\n *   instance,\r\n *   '0x1234567890123456789012345678901234567890',\r\n *   'address'\r\n * )\r\n * ```\r\n */\r\nexport async function encryptValue<T extends InputType>(\r\n  instance: FhevmInstance,\r\n  value: number | boolean | bigint | string,\r\n  type: T\r\n): Promise<EncryptedValue<T>> {\r\n  // Validate instance is ready\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  // Validate input\r\n  validateEncryptionInput(value, type)\r\n\r\n  // Normalize value\r\n  const normalized = normalizeValue(value, type)\r\n\r\n  try {\r\n    // Encrypt using fhevmjs\r\n    const encrypted = await encryptWithFhevmjs(instance, normalized, type)\r\n\r\n    return {\r\n      data: encrypted,\r\n      type,\r\n      encryptedType: getEncryptedType(type),\r\n    }\r\n  } catch (error) {\r\n    throw new EncryptionError(`Failed to encrypt ${type}: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Encrypt value using fhevmjs instance\r\n */\r\nasync function encryptWithFhevmjs(\r\n  instance: FhevmInstance,\r\n  value: number | boolean | bigint | string,\r\n  type: InputType\r\n): Promise<Uint8Array> {\r\n  const fhevmInstance = instance.instance\r\n\r\n  switch (type) {\r\n    case 'bool':\r\n      return fhevmInstance.encrypt_bool(value as boolean)\r\n\r\n    case 'uint8':\r\n      return fhevmInstance.encrypt_uint8(Number(value))\r\n\r\n    case 'uint16':\r\n      return fhevmInstance.encrypt_uint16(Number(value))\r\n\r\n    case 'uint32':\r\n      return fhevmInstance.encrypt_uint32(Number(value))\r\n\r\n    case 'uint64':\r\n      return fhevmInstance.encrypt_uint64(BigInt(value))\r\n\r\n    case 'uint128':\r\n      return fhevmInstance.encrypt_uint128(BigInt(value))\r\n\r\n    case 'uint256':\r\n      return fhevmInstance.encrypt_uint256(BigInt(value))\r\n\r\n    case 'address':\r\n      return fhevmInstance.encrypt_address(value as string)\r\n\r\n    case 'bytes':\r\n      return fhevmInstance.encrypt_bytes256(value as string)\r\n\r\n    default:\r\n      throw new EncryptionError(`Unsupported encryption type: ${type}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Encrypt multiple values at once\r\n *\r\n * @param instance - FHEVM instance\r\n * @param values - Array of values with their types\r\n * @returns Promise resolving to array of encrypted values\r\n *\r\n * @example\r\n * ```typescript\r\n * const encrypted = await encryptBatch(instance, [\r\n *   { value: 42, type: 'uint32' },\r\n *   { value: true, type: 'bool' },\r\n *   { value: 100n, type: 'uint64' }\r\n * ])\r\n * ```\r\n */\r\nexport async function encryptBatch(\r\n  instance: FhevmInstance,\r\n  values: Array<{ value: number | boolean | bigint | string; type: InputType }>\r\n): Promise<EncryptedValue[]> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  try {\r\n    const encrypted = await Promise.all(\r\n      values.map(({ value, type }) => encryptValue(instance, value, type))\r\n    )\r\n    return encrypted\r\n  } catch (error) {\r\n    throw new EncryptionError(`Batch encryption failed: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Convert encrypted value to contract input format\r\n *\r\n * @param encrypted - Encrypted value\r\n * @returns Formatted data for contract call\r\n *\r\n * @example\r\n * ```typescript\r\n * const encrypted = await encryptValue(instance, 42, 'uint32')\r\n * const input = toContractInput(encrypted)\r\n * await contract.submitValue(input)\r\n * ```\r\n */\r\nexport function toContractInput(encrypted: EncryptedValue): Uint8Array {\r\n  return encrypted.data\r\n}\r\n\r\n/**\r\n * Convert encrypted value to hex string\r\n *\r\n * @param encrypted - Encrypted value\r\n * @returns Hex string representation\r\n */\r\nexport function toHex(encrypted: EncryptedValue): string {\r\n  return '0x' + Array.from(encrypted.data).map((b) => b.toString(16).padStart(2, '0')).join('')\r\n}\r\n\r\n/**\r\n * Get size of encrypted value in bytes\r\n *\r\n * @param encrypted - Encrypted value\r\n * @returns Size in bytes\r\n */\r\nexport function getEncryptedSize(encrypted: EncryptedValue): number {\r\n  return encrypted.data.length\r\n}\r\n\r\n/**\r\n * Check if two encrypted values are equal (same ciphertext)\r\n *\r\n * @param a - First encrypted value\r\n * @param b - Second encrypted value\r\n * @returns True if equal\r\n */\r\nexport function areEncryptedValuesEqual(a: EncryptedValue, b: EncryptedValue): boolean {\r\n  if (a.data.length !== b.data.length) {\r\n    return false\r\n  }\r\n\r\n  for (let i = 0; i < a.data.length; i++) {\r\n    if (a.data[i] !== b.data[i]) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n","/**\r\n * React hook for encryption functionality\r\n */\r\n\r\nimport { useState, useCallback } from 'react'\r\nimport { useFhevm } from './useFhevm'\r\nimport { encryptValue } from '../../core/encryption'\r\nimport type { UseEncryptResult, InputType, EncryptedValue } from '../../types'\r\n\r\n/**\r\n * Hook for encrypting values\r\n *\r\n * @returns Encryption utilities\r\n *\r\n * @example\r\n * ```typescript\r\n * function MyComponent() {\r\n *   const { encrypt, encrypting, error } = useEncrypt()\r\n *\r\n *   const handleSubmit = async (value: number) => {\r\n *     try {\r\n *       const encrypted = await encrypt(value, 'uint32')\r\n *       // Use encrypted data with contract\r\n *       await contract.submitValue(encrypted.data)\r\n *     } catch (err) {\r\n *       console.error('Encryption failed:', err)\r\n *     }\r\n *   }\r\n *\r\n *   return (\r\n *     <button onClick={() => handleSubmit(42)} disabled={encrypting}>\r\n *       {encrypting ? 'Encrypting...' : 'Submit'}\r\n *     </button>\r\n *   )\r\n * }\r\n * ```\r\n */\r\nexport function useEncrypt(): UseEncryptResult {\r\n  const { instance, ready } = useFhevm()\r\n  const [encrypting, setEncrypting] = useState(false)\r\n  const [error, setError] = useState<Error | null>(null)\r\n\r\n  const encrypt = useCallback(\r\n    async <T extends InputType>(\r\n      value: number | boolean | bigint | string,\r\n      type: T\r\n    ): Promise<EncryptedValue<T>> => {\r\n      if (!instance || !ready) {\r\n        const err = new Error('FHEVM instance not ready')\r\n        setError(err)\r\n        throw err\r\n      }\r\n\r\n      setEncrypting(true)\r\n      setError(null)\r\n\r\n      try {\r\n        const encrypted = await encryptValue(instance, value, type)\r\n        return encrypted\r\n      } catch (err) {\r\n        const error = err instanceof Error ? err : new Error(String(err))\r\n        setError(error)\r\n        throw error\r\n      } finally {\r\n        setEncrypting(false)\r\n      }\r\n    },\r\n    [instance, ready]\r\n  )\r\n\r\n  return {\r\n    encrypt,\r\n    encrypting,\r\n    error,\r\n  }\r\n}\r\n","/**\r\n * Decryption utilities for FHEVM via Gateway\r\n */\r\n\r\nimport type { FhevmInstance, EncryptedType } from '../types'\r\nimport { validateContractAddress, validateHandle } from '../utils/validation'\r\nimport { DecryptionError, FhevmNotReadyError } from '../utils/errors'\r\n// import { getSigner } from './instance' // For future use\r\n\r\n/**\r\n * Request decryption of an encrypted value via the Gateway\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Address of the contract holding the encrypted value\r\n * @param handle - Handle/identifier of the encrypted value (ciphertext)\r\n * @param type - Expected type of the decrypted value\r\n * @returns Promise resolving to decrypted value\r\n *\r\n * @example\r\n * ```typescript\r\n * // After submitting encrypted data to contract and getting a handle\r\n * const decrypted = await requestDecryption(\r\n *   instance,\r\n *   '0x1234...', // contract address\r\n *   '0xabcd...', // ciphertext handle\r\n *   'uint32'\r\n * )\r\n * console.log('Decrypted value:', decrypted)\r\n * ```\r\n */\r\nexport async function requestDecryption<T = unknown>(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  type?: EncryptedType\r\n): Promise<T> {\r\n  // Validate instance\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  // Validate inputs\r\n  validateContractAddress(contractAddress)\r\n  validateHandle(handle)\r\n\r\n  try {\r\n    // Get signer for signing the decryption request (for future use)\r\n    // const signer = await getSigner(instance)\r\n    // const userAddress = await signer.getAddress()\r\n\r\n    // Create decryption request using fhevmjs - currently uses instance's internal methods\r\n    if (!instance.instance.decrypt) {\r\n      throw new DecryptionError('Decryption not supported by this instance')\r\n    }\r\n    const result = await instance.instance.decrypt(contractAddress, handle)\r\n\r\n    // Parse result based on type\r\n    return parseDecryptionResult<T>(result, type)\r\n  } catch (error) {\r\n    throw new DecryptionError(`Failed to decrypt value: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Request decryption with explicit permission signature\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @param signature - Permission signature from user\r\n * @param type - Expected type\r\n * @returns Decrypted value\r\n */\r\nexport async function requestDecryptionWithSignature<T = unknown>(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  signature: string,\r\n  type?: EncryptedType\r\n): Promise<T> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  validateContractAddress(contractAddress)\r\n  validateHandle(handle)\r\n\r\n  try {\r\n    // Use provided signature instead of generating new one\r\n    if (!instance.instance.decrypt) {\r\n      throw new DecryptionError('Decryption not supported by this instance')\r\n    }\r\n    const result = await instance.instance.decrypt(contractAddress, handle, signature)\r\n    return parseDecryptionResult<T>(result, type)\r\n  } catch (error) {\r\n    throw new DecryptionError(`Failed to decrypt with signature: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Request batch decryption\r\n *\r\n * @param instance - FHEVM instance\r\n * @param requests - Array of decryption requests\r\n * @returns Array of decrypted values\r\n *\r\n * @example\r\n * ```typescript\r\n * const results = await requestBatchDecryption(instance, [\r\n *   { contractAddress: '0x123...', handle: '0xabc...', type: 'uint32' },\r\n *   { contractAddress: '0x123...', handle: '0xdef...', type: 'bool' }\r\n * ])\r\n * ```\r\n */\r\nexport async function requestBatchDecryption(\r\n  instance: FhevmInstance,\r\n  requests: Array<{\r\n    contractAddress: string\r\n    handle: string\r\n    type?: EncryptedType\r\n  }>\r\n): Promise<unknown[]> {\r\n  if (!instance || !instance.ready) {\r\n    throw new FhevmNotReadyError()\r\n  }\r\n\r\n  try {\r\n    const results = await Promise.all(\r\n      requests.map(({ contractAddress, handle, type }) =>\r\n        requestDecryption(instance, contractAddress, handle, type)\r\n      )\r\n    )\r\n    return results\r\n  } catch (error) {\r\n    throw new DecryptionError(`Batch decryption failed: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Parse decryption result based on expected type\r\n */\r\nfunction parseDecryptionResult<T>(result: any, type?: EncryptedType): T {\r\n  if (type === undefined) {\r\n    return result as T\r\n  }\r\n\r\n  switch (type) {\r\n    case 'ebool':\r\n      return Boolean(result) as T\r\n\r\n    case 'euint4':\r\n    case 'euint8':\r\n    case 'euint16':\r\n    case 'euint32':\r\n      return Number(result) as T\r\n\r\n    case 'euint64':\r\n    case 'euint128':\r\n    case 'euint256':\r\n      return BigInt(result) as T\r\n\r\n    case 'eaddress':\r\n      return String(result) as T\r\n\r\n    case 'ebytes64':\r\n    case 'ebytes128':\r\n    case 'ebytes256':\r\n      return String(result) as T\r\n\r\n    default:\r\n      return result as T\r\n  }\r\n}\r\n\r\n/**\r\n * Wait for decryption to be fulfilled\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @param options - Polling options\r\n * @returns Decrypted value when ready\r\n *\r\n * @example\r\n * ```typescript\r\n * // Wait up to 30 seconds, polling every 2 seconds\r\n * const value = await waitForDecryption(\r\n *   instance,\r\n *   contractAddress,\r\n *   handle,\r\n *   { timeout: 30000, interval: 2000 }\r\n * )\r\n * ```\r\n */\r\nexport async function waitForDecryption<T = unknown>(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string,\r\n  options: {\r\n    timeout?: number\r\n    interval?: number\r\n    type?: EncryptedType\r\n  } = {}\r\n): Promise<T> {\r\n  const { timeout = 60000, interval = 1000, type } = options\r\n\r\n  const startTime = Date.now()\r\n\r\n  while (Date.now() - startTime < timeout) {\r\n    try {\r\n      const result = await requestDecryption<T>(instance, contractAddress, handle, type)\r\n      return result\r\n    } catch (error) {\r\n      // If it's a \"not ready\" error, wait and retry\r\n      if (error instanceof DecryptionError && error.message.includes('not ready')) {\r\n        await new Promise((resolve) => setTimeout(resolve, interval))\r\n        continue\r\n      }\r\n      // Other errors should be thrown immediately\r\n      throw error\r\n    }\r\n  }\r\n\r\n  throw new DecryptionError(`Decryption timeout after ${timeout}ms`)\r\n}\r\n\r\n/**\r\n * Check if decryption is available for a handle\r\n *\r\n * @param instance - FHEVM instance\r\n * @param contractAddress - Contract address\r\n * @param handle - Ciphertext handle\r\n * @returns True if decryption is available\r\n */\r\nexport async function isDecryptionReady(\r\n  instance: FhevmInstance,\r\n  contractAddress: string,\r\n  handle: string\r\n): Promise<boolean> {\r\n  try {\r\n    await requestDecryption(instance, contractAddress, handle)\r\n    return true\r\n  } catch (error) {\r\n    return false\r\n  }\r\n}\r\n","/**\r\n * React hook for decryption functionality\r\n */\r\n\r\nimport { useState, useCallback } from 'react'\r\nimport { useFhevm } from './useFhevm'\r\nimport { requestDecryption } from '../../core/decryption'\r\nimport type { UseDecryptResult, EncryptedType } from '../../types'\r\n\r\n/**\r\n * Hook for decrypting values\r\n *\r\n * @returns Decryption utilities\r\n *\r\n * @example\r\n * ```typescript\r\n * function MyComponent() {\r\n *   const { decrypt, requesting, error } = useDecrypt()\r\n *   const [value, setValue] = useState<number | null>(null)\r\n *\r\n *   const handleDecrypt = async () => {\r\n *     try {\r\n *       const decrypted = await decrypt<number>(\r\n *         contractAddress,\r\n *         ciphertextHandle,\r\n *         'euint32'\r\n *       )\r\n *       setValue(decrypted)\r\n *     } catch (err) {\r\n *       console.error('Decryption failed:', err)\r\n *     }\r\n *   }\r\n *\r\n *   return (\r\n *     <div>\r\n *       <button onClick={handleDecrypt} disabled={requesting}>\r\n *         {requesting ? 'Decrypting...' : 'Decrypt'}\r\n *       </button>\r\n *       {value !== null && <p>Decrypted value: {value}</p>}\r\n *     </div>\r\n *   )\r\n * }\r\n * ```\r\n */\r\nexport function useDecrypt(): UseDecryptResult {\r\n  const { instance, ready } = useFhevm()\r\n  const [requesting, setRequesting] = useState(false)\r\n  const [error, setError] = useState<Error | null>(null)\r\n\r\n  const decrypt = useCallback(\r\n    async <T = unknown>(\r\n      contractAddress: string,\r\n      handle: string,\r\n      type?: EncryptedType\r\n    ): Promise<T> => {\r\n      if (!instance || !ready) {\r\n        const err = new Error('FHEVM instance not ready')\r\n        setError(err)\r\n        throw err\r\n      }\r\n\r\n      setRequesting(true)\r\n      setError(null)\r\n\r\n      try {\r\n        const decrypted = await requestDecryption<T>(instance, contractAddress, handle, type)\r\n        return decrypted\r\n      } catch (err) {\r\n        const error = err instanceof Error ? err : new Error(String(err))\r\n        setError(error)\r\n        throw error\r\n      } finally {\r\n        setRequesting(false)\r\n      }\r\n    },\r\n    [instance, ready]\r\n  )\r\n\r\n  return {\r\n    decrypt,\r\n    requesting,\r\n    error,\r\n  }\r\n}\r\n","/**\r\n * Network configuration utilities for FHEVM SDK\r\n */\r\n\r\nimport type { NetworkName, NetworkConfig } from '../types'\r\nimport { NetworkError } from './errors'\r\n\r\n/**\r\n * Predefined network configurations\r\n */\r\nexport const NETWORK_CONFIGS: Record<NetworkName, NetworkConfig> = {\r\n  sepolia: {\r\n    name: 'sepolia',\r\n    chainId: 11155111,\r\n    rpcUrl: 'https://sepolia.infura.io/v3/',\r\n    gatewayUrl: 'https://gateway.sepolia.zama.ai',\r\n    aclAddress: '0x9d6f6d3D3D3D3D3D3D3D3D3D3D3D3D3D3D3D3D3D',\r\n  },\r\n  mainnet: {\r\n    name: 'mainnet',\r\n    chainId: 1,\r\n    rpcUrl: 'https://mainnet.infura.io/v3/',\r\n    gatewayUrl: 'https://gateway.zama.ai',\r\n    aclAddress: '0x0000000000000000000000000000000000000000',\r\n  },\r\n  localhost: {\r\n    name: 'localhost',\r\n    chainId: 31337,\r\n    rpcUrl: 'http://localhost:8545',\r\n    gatewayUrl: 'http://localhost:3000',\r\n  },\r\n  custom: {\r\n    name: 'custom',\r\n    chainId: 0,\r\n    rpcUrl: '',\r\n    gatewayUrl: '',\r\n  },\r\n}\r\n\r\n/**\r\n * Get network configuration by name\r\n */\r\nexport function getNetworkConfig(network: NetworkName): NetworkConfig {\r\n  const config = NETWORK_CONFIGS[network]\r\n  if (!config) {\r\n    throw new NetworkError(`Unknown network: ${network}`)\r\n  }\r\n  return { ...config }\r\n}\r\n\r\n/**\r\n * Validate network configuration\r\n */\r\nexport function validateNetworkConfig(config: NetworkConfig): void {\r\n  if (!config.chainId || config.chainId <= 0) {\r\n    throw new NetworkError('Invalid chainId')\r\n  }\r\n\r\n  if (!config.rpcUrl || !isValidUrl(config.rpcUrl)) {\r\n    throw new NetworkError('Invalid RPC URL')\r\n  }\r\n\r\n  if (!config.gatewayUrl || !isValidUrl(config.gatewayUrl)) {\r\n    throw new NetworkError('Invalid gateway URL')\r\n  }\r\n}\r\n\r\n/**\r\n * Merge custom config with default network config\r\n */\r\nexport function mergeNetworkConfig(\r\n  network: NetworkName,\r\n  customConfig: Partial<NetworkConfig>\r\n): NetworkConfig {\r\n  const baseConfig = getNetworkConfig(network)\r\n  const merged = { ...baseConfig, ...customConfig }\r\n  validateNetworkConfig(merged)\r\n  return merged\r\n}\r\n\r\n/**\r\n * Validate URL format\r\n */\r\nfunction isValidUrl(url: string): boolean {\r\n  try {\r\n    new URL(url)\r\n    return true\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Get chain ID from network name\r\n */\r\nexport function getChainId(network: NetworkName): number {\r\n  return getNetworkConfig(network).chainId\r\n}\r\n\r\n/**\r\n * Get gateway URL from network name\r\n */\r\nexport function getGatewayUrl(network: NetworkName): string {\r\n  return getNetworkConfig(network).gatewayUrl\r\n}\r\n\r\n/**\r\n * Check if network is supported\r\n */\r\nexport function isSupportedNetwork(network: string): network is NetworkName {\r\n  return network in NETWORK_CONFIGS\r\n}\r\n","/**\r\n * FHEVM instance creation and management\r\n */\r\n\r\nimport { createInstance } from 'fhevmjs'\r\nimport { BrowserProvider, JsonRpcProvider, type Signer, type Provider } from 'ethers'\r\nimport type {\r\n  FhevmConfig,\r\n  FhevmInstance,\r\n  FhevmjsInstance,\r\n  NetworkConfig,\r\n  NetworkName,\r\n} from '../types'\r\nimport { getNetworkConfig, validateNetworkConfig } from '../utils/network'\r\nimport { NetworkError, FhevmError } from '../utils/errors'\r\n\r\n/**\r\n * Create a new FHEVM instance\r\n *\r\n * @param config - Configuration for the FHEVM instance\r\n * @returns Promise resolving to an FhevmInstance\r\n *\r\n * @example\r\n * ```typescript\r\n * // Simple usage with network name\r\n * const instance = await createFhevmInstance({ network: 'sepolia' })\r\n *\r\n * // With custom provider\r\n * const provider = new BrowserProvider(window.ethereum)\r\n * const instance = await createFhevmInstance({\r\n *   network: 'sepolia',\r\n *   provider\r\n * })\r\n *\r\n * // With full custom config\r\n * const instance = await createFhevmInstance({\r\n *   network: {\r\n *     name: 'custom',\r\n *     chainId: 31337,\r\n *     rpcUrl: 'http://localhost:8545',\r\n *     gatewayUrl: 'http://localhost:3000'\r\n *   }\r\n * })\r\n * ```\r\n */\r\nexport async function createFhevmInstance(config: FhevmConfig): Promise<FhevmInstance> {\r\n  try {\r\n    // Parse network configuration\r\n    const networkConfig = parseNetworkConfig(config)\r\n\r\n    // Provider available for future use if needed\r\n    // const provider = config.provider || (await getDefaultProvider(networkConfig))\r\n\r\n    // Create fhevmjs instance\r\n    const fhevmjsInstance = await createInstance({\r\n      networkUrl: networkConfig.rpcUrl,\r\n      gatewayUrl: networkConfig.gatewayUrl,\r\n      aclAddress: networkConfig.aclAddress,\r\n      chainId: networkConfig.chainId,\r\n    })\r\n\r\n    // Get public key\r\n    const publicKey = fhevmjsInstance.getPublicKey()\r\n\r\n    return {\r\n      instance: fhevmjsInstance as any as FhevmjsInstance,\r\n      config: networkConfig,\r\n      ready: true,\r\n      publicKey: publicKey || undefined,\r\n    } as FhevmInstance\r\n  } catch (error) {\r\n    throw new FhevmError(`Failed to create FHEVM instance: ${error}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Parse network configuration from user input\r\n */\r\nfunction parseNetworkConfig(config: FhevmConfig): NetworkConfig {\r\n  if (typeof config.network === 'string') {\r\n    // Network name provided\r\n    const baseConfig = getNetworkConfig(config.network as NetworkName)\r\n\r\n    // Merge with custom values\r\n    const merged: NetworkConfig = {\r\n      ...baseConfig,\r\n      ...(config.gatewayUrl && { gatewayUrl: config.gatewayUrl }),\r\n      ...(config.chainId && { chainId: config.chainId }),\r\n    }\r\n\r\n    validateNetworkConfig(merged)\r\n    return merged\r\n  }\r\n\r\n  // Full network config provided\r\n  const networkConfig = config.network as NetworkConfig\r\n  validateNetworkConfig(networkConfig)\r\n  return networkConfig\r\n}\r\n\r\n/**\r\n * Get default provider for the network\r\n */\r\nasync function getDefaultProvider(config: NetworkConfig): Promise<Provider> {\r\n  // Try to use browser provider first (MetaMask, etc.)\r\n  if (typeof window !== 'undefined' && (window as any).ethereum) {\r\n    try {\r\n      const browserProvider = new BrowserProvider((window as any).ethereum)\r\n      const network = await browserProvider.getNetwork()\r\n\r\n      // Verify chain ID matches\r\n      if (Number(network.chainId) !== config.chainId) {\r\n        throw new NetworkError(\r\n          `Connected wallet is on chain ${network.chainId}, expected ${config.chainId}`\r\n        )\r\n      }\r\n\r\n      return browserProvider\r\n    } catch (error) {\r\n      console.warn('Browser provider not available or wrong network:', error)\r\n    }\r\n  }\r\n\r\n  // Fallback to JSON-RPC provider\r\n  return new JsonRpcProvider(config.rpcUrl, config.chainId)\r\n}\r\n\r\n/**\r\n * Get signer from provider\r\n */\r\nexport async function getSigner(instance: FhevmInstance, provider?: Provider): Promise<Signer> {\r\n  const targetProvider = provider || (await getDefaultProvider(instance.config))\r\n\r\n  if ('getSigner' in targetProvider && typeof targetProvider.getSigner === 'function') {\r\n    return await (targetProvider as any).getSigner()\r\n  }\r\n\r\n  throw new FhevmError('Provider does not support getting signer')\r\n}\r\n\r\n\r\n/**\r\n * Check if FHEVM instance is ready\r\n */\r\nexport function isInstanceReady(instance: FhevmInstance | null): instance is FhevmInstance {\r\n  return instance !== null && instance.ready\r\n}\r\n\r\n/**\r\n * Get public key from instance\r\n */\r\nexport function getPublicKey(instance: FhevmInstance): string {\r\n  if (!instance.publicKey) {\r\n    const key = instance.instance.getPublicKey()\r\n    instance.publicKey = key || undefined\r\n  }\r\n\r\n  if (!instance.publicKey) {\r\n    throw new FhevmError('Public key not available')\r\n  }\r\n\r\n  return instance.publicKey\r\n}\r\n\r\n/**\r\n * Reinitialize FHEVM instance with new configuration\r\n */\r\nexport async function reinitializeInstance(\r\n  currentInstance: FhevmInstance,\r\n  newConfig: Partial<FhevmConfig>\r\n): Promise<FhevmInstance> {\r\n  const mergedConfig: FhevmConfig = {\r\n    network: currentInstance.config,\r\n    ...newConfig,\r\n  }\r\n\r\n  return await createFhevmInstance(mergedConfig)\r\n}\r\n","/**\r\n * React Provider for FHEVM instance\r\n */\r\n\r\nimport { useState, useEffect, useMemo } from 'react'\r\nimport { FhevmContext } from '../react/context/FhevmContext'\r\nimport { createFhevmInstance } from '../core/instance'\r\nimport type { FhevmInstance, FhevmConfig, FhevmProviderProps } from '../types'\r\n\r\nexport type { FhevmProviderProps } from '../types'\r\n\r\n/**\r\n * Provider component for FHEVM instance\r\n *\r\n * Wrap your application with this provider to enable FHEVM hooks throughout the component tree.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Simple usage with network name\r\n * function App() {\r\n *   return (\r\n *     <FhevmProvider network=\"sepolia\">\r\n *       <MyApp />\r\n *     </FhevmProvider>\r\n *   )\r\n * }\r\n *\r\n * // With custom configuration\r\n * function App() {\r\n *   return (\r\n *     <FhevmProvider config={{ network: 'sepolia', gatewayUrl: 'https://custom-gateway.com' }}>\r\n *       <MyApp />\r\n *     </FhevmProvider>\r\n *   )\r\n * }\r\n * ```\r\n */\r\nexport function FhevmProvider({ children, network = 'sepolia', config }: FhevmProviderProps) {\r\n  const [instance, setInstance] = useState<FhevmInstance | null>(null)\r\n  const [loading, setLoading] = useState(true)\r\n  const [error, setError] = useState<Error | null>(null)\r\n  const [ready, setReady] = useState(false)\r\n\r\n  useEffect(() => {\r\n    let cancelled = false\r\n\r\n    async function initializeFhevm() {\r\n      try {\r\n        setLoading(true)\r\n        setError(null)\r\n\r\n        // Use provided config or create from network name\r\n        const fhevmConfig: FhevmConfig = config || { network }\r\n\r\n        // Create FHEVM instance\r\n        const fhevmInstance = await createFhevmInstance(fhevmConfig)\r\n\r\n        if (!cancelled) {\r\n          setInstance(fhevmInstance)\r\n          setReady(fhevmInstance.ready)\r\n          setLoading(false)\r\n        }\r\n      } catch (err) {\r\n        if (!cancelled) {\r\n          const error = err instanceof Error ? err : new Error(String(err))\r\n          setError(error)\r\n          setLoading(false)\r\n          setReady(false)\r\n          console.error('Failed to initialize FHEVM:', error)\r\n        }\r\n      }\r\n    }\r\n\r\n    initializeFhevm()\r\n\r\n    return () => {\r\n      cancelled = true\r\n    }\r\n  }, [network, config])\r\n\r\n  const contextValue = useMemo(\r\n    () => ({\r\n      instance,\r\n      ready,\r\n      error,\r\n      loading,\r\n    }),\r\n    [instance, ready, error, loading]\r\n  )\r\n\r\n  return <FhevmContext.Provider value={contextValue}>{children}</FhevmContext.Provider>\r\n}\r\n"]}